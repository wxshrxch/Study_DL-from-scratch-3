# 제 1고지. 미분 자동 계산 (1~4)

## 1-1. 상자로서의 변수

```python
x = Variable(data) # x는 Variable 클래스의 인스턴스, x는 데이터 자체가 아니라 데이터를 담은 상자
```

- 머신러닝 시스템은 **기본 데이터 구조로 ‘numpy의 다차원 배열’**을 사용
- 다차원 배열은 숫자 등의 원소가 일정하게 모여 있는 데이터 구조
- **원소의 순서에는 방향**이 있고, 방향을 **차원(dimension), 축(axis)** 으로 표현
- **0차원 배열, 1차원 배열, 2차원 배열**을 차례대로 **스칼라(scalar), 벡터(vector), 행렬(matrix)**로 표현
    - 스칼라는 단순히 하나의 수를 나타냄
    - 벡터는 하나의 축을 따라 숫자가 늘어서 있고, 행렬은 축이 두 개
- 다차원 배열 = tensor
- ndarray 인스턴스에는 ndim이라는 인스턴스 변수가 있음

### 차원

- array([1,2,3]) 은 벡터 -> 3차원 벡터
- 벡터의 차원은 벡터의 원소 수를 나타냄
- ‘3차원 배열’에서 배열의 차원은 축이 3개라는 것

## 1-2. 변수를 낳는 함수

- 함수란 ‘어떤 변수로부터 다른 변수로의 대응 관계를 정한 것
- 변수 사이의 대응 관계를 정하는 역할
- 계산 그래프(computational graph) : 원과 사각형 모양의 노드들을 화살표로 연결해 계산과정을 표현한 그림
- CS 분야에서 그래프(graph)는 노드(node)와 에지(edge,  변, 간선) 으로 구성된 데이터 구조를 말함

### __call__메서드

- 파이썬의 특수 메서드
    - 함수의 인스턴스를 변수 f에 대입해 두고, 나중에 f(…) 형태로 __call__ 메서드를 호출
    - 즉, 클래스의 객체를 호출 가능하도록 함 (인스턴스 호출 시 실행)
    - 아래의 forward 메서드는 예외를 발생시킴
        
        ```python
        def forward(self,x):
        	raise NotImplementedError()
        ```
        
        - 본 메서드는 상속하여 구현해야 한다 고 알려줌
    

## 1-3. 함수 연결

- $e$ : 자연 로그의 밑(base of the natural logarithm),  오일러의 수 (Euler’s number), 네이피어 상수(Napie’s constant)
- 동일 클래스의 여러 인스턴스는 여러 함수를 연속하여 적용하기 쉬움
- 합성함수(composite function) : 여러 함수로 구성된 함수

## 1-4. 수치 미분

수치미분은 미분을 자동 계산하는 간단한 방법임

머신러닝 외에도 유체 역학, 금융 공학, 가상 시뮬레이션, 엔지니어링 설계 최적화 등의 분야에서 자동 미분 계산 기능을 실제 사용 중

### 미분

- ‘변화율’
- ‘ 극한으로 짧은 시간(순간)’에서의 변화량

### 수치 미분 (numeriacal differentiation)

- 컴퓨터는 극한을 취급할 수 없으니 h를 극한과 비슷한 값으로 대체
    - ex) h = 0.0001 (= 1e-4)
- 미세한 차이를 이용하여 함수의 변화량을 구하는 방법
- 작은 값을 사용하여 미분을 근사함
- 이 때문에 값에 어쩔 수 없이 오차가 포함된다.
- 이러한 근사 오차를 줄이는 방법으로 ‘중앙 차분(centered difference)’가 있다

### 중앙 차분

f(x)와 f(x+h)의 차이 대신 f(x-h)+f(x+h)의 차이를 구함

- x와 x+h 의 지점에서 기울기를 구하는 방법은 ‘전진차분(forward difference)
- x-h와 x+h의 지점에서 기울기를구하는 방법은 ‘중앙 차분’
    - 중앙차분 방식이 상대적으로 오차가 작음
        - 증명은 테일러 급수를 이용

- 미분은 해석적으로도 계산 할 수 있음
    - 해석적으로 = 수식 변형만으로 답을 유도

### 수치 미분의 문제점

- 수치 미분의 결과에는 오차가 포함됨
    - 대부분의 경우 매우 작은 오차가 포함되지만 어떤 계산이냐에 따라 커질 수도 있음
    - 오차가 포함되는 이유는 주로 ‘자릿수 누락’ 때문임
    - 주로 크기가 비슷한 값들을 다루므로 계산 결과에서 자릿수 누락이 생겨 유효 자릿수가 줄어 든다
- 계산량이 많다
    - 변수가 여러 개인 계산을 미분할 경우 변수 각각을 미분해야 함
    - 신경망에서는 매개변수를 수백만개 이상 사용하는 것이 일반적이므로 모두를 수치 미분으로 구하는 것은 어려움
    - 이를 해결하기 위해 역전파 개념이 등장함
- 수치 미분 vs 역전파
    - 수치 미분은 구현하기 쉽고 거의 정확한 값을 얻을 수 있음
    - 역전파는 복잡한 알고리즘이므로 구현하며 버그가 발생하기 쉽다
    - 이에 역전파를 정확하게 구현했는지 확인하기 위해 수치 미분의 결과를 이용한다 (gradient checking)
        - 단순히 수치 미분 결과와 역전파의 결과를 비교